---
title: jvm-类加载
date: 2019-08-04 00:57:25
tags: Java
category: Java
---

![photo by https://unsplash.com/photos/ISVm7Rzhy8s](jvm-类加载机制/load-class.png)

关于 JVM 涉及的知识比较深，并且比较难理解。每次看到不懂的地方，我习惯了解之后记下来。相信了解多了也就会变成自己的知识了。今天周六，准备换地方和朋友一起合租住，想想还是美滋滋。

<!--more-->

#### 类生命周期

一个静态的类从被加载到内存，变成动态类，在到被卸载为止，它的生命周期是：
```java

加载--> 链接--> 初始化--> 使用--> 卸载

链接包含：
验证--> 准备--> 解析
```
类的加载必须按照这个过程来加载，除了解析阶段，有可能发生在初始化阶段之后。

#### 类加载器
JDK 包含类 3 中类加载器。分别是 BootStrap ClassLoader 启动类加载器，Extension ClassLoader 扩展类加载器和 Application ClassLoader 应用程序类加载器，启动类类加载器是用 C++ 实现的，作为 JVM 的一部分，而其他类加载器是用 Java 来实现的，都继承自 java.lang.ClassLoader。

##### 双亲委任

###### 类加载器层级

自定义类加载器 > 应用程序类加载器 > 扩展类加载器 > 启动类加载器

除了启动类加载器之外，每个类都有父类加载器。

双亲委任大致可以理解为：当一个加载器加载一个类时，首先交给它的父类加载器加载此类路径下的类，如果父类找不到，在交给它自己的父类进行加载，如果找到了，则加载此类，如果没有找到，则会告知子类信息，子类才会尝试自己加载。也就是说，如果想自己写一个 `java.lang.String` 类来代替 jdk 本身的 `String` 类是不可以的，就算自己写了类加载器也是不能被加载成功的。


##### 运行时数据区

简单来说，运行时数据区就是 Java 程序运行时的数据在内存中的存放空间。主要包含 方法区、堆、虚拟机栈、本地方法栈、程序计数器。

其中方法区和堆是所有线程共享的，而虚拟机栈、本地方法栈和程序计数器是线程私有的。

###### 方法区

 `.java` 文件被编译为  `.class` 文件后，被类加载器加载到内存需要存放到一个内存区域，这个区域就是方法区，方法区主要存放一些不经常改变的数据，常量，静态变量等都存放在这个区域。就像数据表的建表语句，规定了这张表就应该有哪些属性，这些属性应该是什么类型。当我们 new 一个对象时，就像给这张表添加一条数据，内容可以不一样，当时必须要遵循这些属性的格式。当方法区没有足够的空间时会抛 OutOfMemoryError 异常。


 ###### 堆

堆是 Java 虚拟机管理的内存中最大的一块，这块区域被所有线程共享，这块区域主要用来存放对象，在内存不足的情况下会抛出 OutOfMemoryError 异常。

> 堆是所有线程共享的，用来存放共有的资源

###### 程序计数器

这块区域主要记录当前线程的运行指令的记录。在 cpu 发生线程切换时，程序计数器可以记录当前线程执行的位置，等切回来时可以正确执行。程序计数器是线程私有的，每个线程都拥有一个自己的计数器。

###### 栈

每当一个线程被启动时，Java 虚拟机会创建一个 Java 栈，栈的单位为栈帧，栈可以分为基本类型变量区，执行环境上下文，操作指令几部分。栈的数据是当前栈私有的，其他栈不能访问。

> 栈是线程私有的，简单来说就是用来执行逻辑的地方

###### JIT

> 即时编译，指将一些经常使用的字节码（循环等） 编译成机器本身的字节码来提高运行速度。


###### 流程

```java
public class User {

    public void toWork() {
        System.out.println("how interesting");
    }

    public static void main(String[] args) {
        User user = new User();
        user.toWork();
    }
}
```
这里大致描述下 jvm 执行流程：
1. 首先在方法区寻找 User 类信息。
2. 如果没有找到的话，通过类加载器加载 User 类到方法区。
3. 在堆上 new 一个User 实例，并把此实例的引用添加到主线程的调用栈中。
4. 执行 user.work() 时，jvm 先根据 user 引用找到堆上对应的对象
5. 根据堆上实例对象持有的方法区引用，获取到方法区 User 类信息，获取到 work() 方法的字节码，执行此方法的代码。


#### Java 垃圾回收

##### 垃圾回收算法
1. 标记-清除

顾名思义，先标记在清除，第一个阶段，先标记需要清除的对象，在讲它们全部清除。这种算法存在 2 种不足，标记和清除的效率都不是很高，而且标记和清除之后很容易产生大量的不连续空间碎片。

2. 复制算法

复制算法会把内存分成2块，一块真正投入使用，当这块内存空间不足时，将还在存活的对象复制到另外一块内存中。标记清除算法最大的缺点是回收之后会产生大量空间碎片，而复制算法则不。但是这样在真正使用时只能使用一般的内存，对内存的使用率很低。

3. 标记整理算法

标记整理算法也是有2个阶段，先将还在存活的对象标记出来，然后将存活的对象复制到一端连续的空间，然后直接将边缘外的空间释放掉。

##### jvm 参数

1. -Xms

> 设置堆的最小空间大小

2. -Xmx

> 设置堆的最大空间大小

3. -Xss

> 设置每个线程栈大小

4. -XX:NewSize 

> 设置新生代最小空间大小

5. -XX:MaxNewSize

> 设置新生代最大空间大小

6. -XX:PermSize

> 设置永久代大小

7. -XX:MaxPermSize

> 设置永久代最大空间大小

**老年代空间大小=堆空间大小-年轻代最大空间大小**


##### 垃圾回收器
使用指定的垃圾回收器
> -XX:+Use<垃圾回收器名字>GC
> -XX:+UseSerialGC

###### Serial

1. 配置
> -XX:+UseSerialGC

2. 工作方式
> 它不仅在收集时使用单线程来完成工作，并且在新生代和老年代收集时都会出现 STW (stop the world)现象。
3. 适用场景
> 桌面应用

###### ParNew (ParalleNew)

1. 配置
>-XX:+UseParNewGc

2. 工作方式
> 只针对新生代使用多线程，老年代还是单线程，收集过程中会出现 STW
3. 使用场景
> server 新生代收集器

###### Parallel Scavenge(PS)

1. 配置
> -XX:+UseParallelGC

2. 工作方式
> 可控制吞吐量，所谓吞吐量 = 运行用户代码时间/（运行用户代码时间 + 垃圾收集时间）
> 高吞吐量可以提高 cpu 利用率，提高运算速度。
3. 使用场景
> 计算量比较小，用户交互不多的场景
4. 参数
> -XX:MaxGCPauseMilis          最大垃圾收集停顿时间（大于0毫秒）
> -XX:GCTimeRatio              吞吐量大小（0-100%）
> -XX:+UseAdaptiveSizePolicy   内存调优委托虚拟机管理

###### Parallel Old
1. 配置
> -XX:+UseParallelOldGC

2. 工作方式
> Parallel Scavenge 收集器老年代收集版本。多线程完成工作，采用了“标记-整理” 算法。

3. 使用场景

> 桌面应用场景

###### Concurrent Mark Sweep（CMS）
1. 配置
> -XX:UseConcMarkSweepGC

2. 工作方式
> 基于“标记-清除”算法，在整个过程中都是并发进行的，以获取最短回收停顿时间为目标，整个过程分为4步：初始标记，并发标记，重新标记，并发清除。

3. 使用场景
> 互联网应用服务端

###### G1

1. 配置
> -XX:+UseG1GC
2. 工作方式

> G1算法将堆划分为若干和区域，但它仍然属于分代收集器，这些区域一部分包含新生代，新生代垃圾收集依然采用暂停所有线程的方式，将存货对象拷贝到老年代或者 Survivor 空间。
> 老年代也分成很多区域，G1 收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作，这就意味着在正常处理过程中，G1完成了堆的压缩（至少是部分堆的压缩） ，这样就不会存在 CMS 内存碎片问题了。
> G1 有两种 GC 模式（都是 STW）
> Yong GC 和 Mixed GC


##### JVM 内存分配与回收策略

1. 大对象直接进入老年代
> 大对象是指需要大量连续内存空间的 Java 对象，典型的是很长的字符串或者大数组。
> -XX:PretenureSizeThreshold 可以使大于这个值的对象直接在老年代分配。这样会避免在 Eden 区以及两个 Survivor 区之间发生大量内存复制。

2. 长期存货的对象将进入老年代
> 对象在 Survivor 区中撑过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定值（默认 15），就会将它复制到老年代中。

3. 动态对象年龄判定
> 如果在 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，不需要等到 MaxTenuringThreshold 中要求的年龄。

4. 空间分配担保
> HandlePromotionFailure 检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于该值，将尝试进行一次 Minor GC，如果小于，或者设置不允许冒险，这是就会改为进行一次 FullGC.


##### 字节码执行引擎

1. 输入字节码文件
2. 处理过程是字节码解析的过程
3. 输出的是执行结果

虚拟机的执行引擎则是由自己实现的，因此可以自行指定指令集与执行引擎的结构体系，并且能够执行哪些不被硬件直接支持的指令集格式。

###### 栈帧

每个方法从调用开始至执行完成都会对应从入栈到出栈的过程，栈帧中包含：
1. 局部变量表
2. 操作数栈
3. 动态链接
4. 返回地址
5. ...

一个栈帧需要分配多少内存，在编译的时候已经确定，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

局部变量表

局部变量表是一组变量存储空间，用于存放方法参数和方法内部定义的局部变量，在 Java 程序编译为 class 文件时，就在 code 属性的 max_local 数据项中确定了该方法所需要分配的局部变量表最大容量。

> 一个 Slot 可以存放一个 32 位以内的数据类型，对于 64 位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的 Slot 空间。

操作数栈

操作数栈是一个后入先出栈，和局部变量一样，操作数栈最大深度也在编译的时候写入到 code 属性的 max_stacks 数据项中。

方法返回地址

当一个方法开始执行后，只有两种方式可以推出这个方法。
1. 执行引擎遇到任意一个方法返回的字节码指令。
2. 在方法执行过程中遇到了异常，并没有在方法体内得到处理。

方法退出的过程实际上就是等同于把当前栈帧出栈
1. 恢复上层方法的局部变量表和操作数栈
2. 把返回值（若存在）压入调用者栈帧的操作数栈中
3. 调正 PC 计数器的值以指向方法调用指令后面的一条指令等

方法调用

方法调用并不等于方法执行，该阶段唯一的任务就是确定哪一个方法，方法在实际运行时内存中的入口地址需要在类加载期间，甚至到运行期间才能确定。

虚方法

可以被复写的方法都可以称作虚方法，虚方法不需要做特殊声明，可以理解为除了 static，final，private 修饰的都是虚方法。

虚拟机动态分派机制

虚方法表（vtable，invokeinterface 执行时调用到 itable）使用虚方法表索引来代替元数据查找来提高性能，虚方法表中存放着各个方法的实际入口地址。

1. 如果方法在子类中没有被重写，那子类虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都是指向父类的实现入口。
2. 如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。

