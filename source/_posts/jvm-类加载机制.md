---
title: jvm-类加载
date: 2019-08-04 00:57:25
tags: Java
category: Java
---

![photo by https://unsplash.com/photos/ISVm7Rzhy8s](jvm-类加载机制/load-class.png)

关于 JVM 涉及的知识比较深，并且比较难理解。每次看到不懂的地方，我习惯了解之后记下来。相信了解多了也就会变成自己的知识了。今天周六，准备换地方和朋友一起合租住，想想还是美滋滋。

<!--more-->

#### 类生命周期

一个静态的类从被加载到内存，变成动态类，在到被卸载为止，它的生命周期是：
```java

加载--> 链接--> 初始化--> 使用--> 卸载

链接包含：
验证--> 准备--> 解析
```
类的加载必须按照这个过程来加载，除了解析阶段，有可能发生在初始化阶段之后。

#### 类加载器
JDK 包含类 3 中类加载器。分别是 BootStrap ClassLoader 启动类加载器，Extension ClassLoader 扩展类加载器和 Application ClassLoader 应用程序类加载器，启动类类加载器是用 C++ 实现的，作为 JVM 的一部分，而其他类加载器是用 Java 来实现的，都继承自 java.lang.ClassLoader。

##### 双亲委任

###### 类加载器层级

自定义类加载器 > 应用程序类加载器 > 扩展类加载器 > 启动类加载器

除了启动类加载器之外，每个类都有父类加载器。

双亲委任大致可以理解为：当一个加载器加载一个类时，首先交给它的父类加载器加载此类路径下的类，如果父类找不到，在交给它自己的父类进行加载，如果找到了，则加载此类，如果没有找到，则会告知子类信息，子类才会尝试自己加载。也就是说，如果想自己写一个 `java.lang.String` 类来代替 jdk 本身的 `String` 类是不可以的，就算自己写了类加载器也是不能被加载成功的。


##### 运行时数据区

简单来说，运行时数据区就是 Java 程序运行时的数据在内存中的存放空间。主要包含 方法区、堆、虚拟机栈、本地方法栈、程序计数器。

其中方法区和堆是所有线程共享的，而虚拟机栈、本地方法栈和程序计数器是线程私有的。

###### 方法区

 `.java` 文件被编译为  `.class` 文件后，被类加载器加载到内存需要存放到一个内存区域，这个区域就是方法区，方法区主要存放一些不经常改变的数据，常量，静态变量等都存放在这个区域。就像数据表的建表语句，规定了这张表就应该有哪些属性，这些属性应该是什么类型。当我们 new 一个对象时，就像给这张表添加一条数据，内容可以不一样，当时必须要遵循这些属性的格式。当方法区没有足够的空间时会抛 OutOfMemoryError 异常。


 ###### 堆

堆是 Java 虚拟机管理的内存中最大的一块，这块区域被所有线程共享，这块区域主要用来存放对象，在内存不足的情况下会抛出 OutOfMemoryError 异常。

> 堆是所有线程共享的，用来存放共有的资源

###### 程序计数器

这块区域主要记录当前线程的运行指令的记录。在 cpu 发生线程切换时，程序计数器可以记录当前线程执行的位置，等切回来时可以正确执行。程序计数器是线程私有的，每个线程都拥有一个自己的计数器。

###### 栈

每当一个线程被启动时，Java 虚拟机会创建一个 Java 栈，栈的单位为栈帧，栈可以分为基本类型变量区，执行环境上下文，操作指令几部分。栈的数据是当前栈私有的，其他栈不能访问。

> 栈是线程私有的，简单来说就是用来执行逻辑的地方

###### JIT

> 即时编译，指将一些经常使用的字节码（循环等） 编译成机器本身的字节码来提高运行速度。


###### 流程

```java
public class User {

    public void toWork() {
        System.out.println("how interesting");
    }

    public static void main(String[] args) {
        User user = new User();
        user.toWork();
    }
}
```
这里大致描述下 jvm 执行流程：
1. 首先在方法区寻找 User 类信息。
2. 如果没有找到的话，通过类加载器加载 User 类到方法区。
3. 在堆上 new 一个User 实例，并把此实例的引用添加到主线程的调用栈中。
4. 执行 user.work() 时，jvm 先根据 user 引用找到堆上对应的对象
5. 根据堆上实例对象持有的方法区引用，获取到方法区 User 类信息，获取到 work() 方法的字节码，执行此方法的代码。


#### Java 垃圾回收

##### 垃圾回收算法
1. 标记-清除

顾名思义，先标记在清除，第一个阶段，先标记需要清除的对象，在讲它们全部清除。这种算法存在 2 种不足，标记和清除的效率都不是很高，而且标记和清除之后很容易产生大量的不连续空间碎片。

2. 复制算法

复制算法会把内存分成2块，一块真正投入使用，当这块内存空间不足时，将还在存活的对象复制到另外一块内存中。标记清除算法最大的缺点是回收之后会产生大量空间碎片，而复制算法则不。但是这样在真正使用时只能使用一般的内存，对内存的使用率很低。

3. 标记整理算法

标记整理算法也是有2个阶段，先将还在存活的对象标记出来，然后将存活的对象复制到一端连续的空间，然后直接将边缘外的空间释放掉。

##### jvm 参数

1. -Xms

> 设置堆的最小空间大小

2. -Xmx

> 设置堆的最大空间大小

3. -Xss

> 设置每个线程栈大小

4. -XX:NewSize 

> 设置新生代最小空间大小

5. -XX:MaxNewSize

> 设置新生代最大空间大小

6. -XX:PermSize

> 设置永久代大小

7. -XX:MaxPermSize

> 设置永久代最大空间大小

**老年代空间大小=堆空间大小-年轻代最大空间大小**


##### 垃圾回收器
使用指定的垃圾回收器
> -XX:+Use<垃圾回收器名字>GC
> -XX:+UseSerialGC

###### Serial

1. 配置
> -XX:+UseSerialGC

2. 工作方式
> 它不仅在收集时使用单线程来完成工作，并且在新生代和老年代收集时都会出现 STW (stop the world)现象。
3. 适用场景
> 桌面应用

###### ParNew (ParalleNew)

1. 配置
>-XX:+UseParNewGc

2. 工作方式
> 只针对新生代使用多线程，老年代还是单线程，收集过程中会出现 STW
3. 使用场景
> server 新生代收集器

###### Parallel Scavenge(PS)

1. 配置
> -XX:+UseParallelGC

2. 工作方式
> 可控制吞吐量，所谓吞吐量 = 运行用户代码时间/（运行用户代码时间 + 垃圾收集时间）


