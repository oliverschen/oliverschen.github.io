---
title: 并发编程
date: 2020-02-04 18:02:45
tags: [Java,多线程]
category: [Java,多线程]
comments: true
---

![Photo by WoshWosh on wallhaven.cc](/duoxiancheng.png)


多线程是提高 CPU 利用率，以及提高执行效率的有效方法之一，但是多线程使用不当会造成会多问题，比如多线程并发下共享资源问、线程之间的协作通信问题，都是需要注意和深入学习的地方。新冠肺炎大家家门都出不了，正好拿来补补知识。（武汉加油！中国加油！）

<!--more-->

### 问题

在主线程中开启一个子线程，等待子线程执行完成返回结果后再继续执行主线程，一共有多少种写法？
这个问题实现的方式确实有很多种，下面是我写的一些方法。

### 模板方法
模板方法是一种设计模式，简单来说就是将公共的操作抽象封装起来，将需要实现的方法写成抽象类给不同的子类来实现。是一种比较实用且理解简单且用云广泛的设计模式之一。

#### Base类
```java
/**
 * @author ck
 * 统一基础类
 */
public abstract class AbstractBase {

    public abstract int asyncInvoke() throws Exception;

    /**
     * 模板
     */
    public void template() {
        long start=System.currentTimeMillis();
        // 在这里创建一个线程或线程池，
        // 异步执行 下面方法

        int result = 0;
        try {
            result = asyncInvoke();
        } catch (Exception e) {
            e.printStackTrace();
        }
        // 确保  拿到result 并输出
        System.out.println("异步计算结果为："+result);
        System.out.println("使用时间："+ (System.currentTimeMillis()-start) + " ms");

        // 然后退出main线程
    }

    public static int sum() {
        return fibo(36);
    }

    private static int fibo(int a) {
        if ( a < 2)
            return 1;
        return fibo(a-1) + fibo(a-2);
    }

    /**
     * 自定义线程池
     */
    public ThreadPoolExecutor getPool(Integer poolSize, Integer queueSize) {
        AtomicInteger num = new AtomicInteger(0);
        return new ThreadPoolExecutor(1, poolSize, 60L, SECONDS,
                new LinkedBlockingDeque<>(queueSize),
                r -> {
                    Thread t = new Thread(r);
                    t.setName("my-" + num.incrementAndGet());
                    t.setDaemon(false);
                    return t;
                });
    }

}
```
#### CompletableFutrue
CompletableFutrue 异步工具类实现。

```java
/**
 * @author ck
 * 使用 CompletableFutrue 实现
 */
public class V1 extends AbstractBase{

    public static void main(String[] args) {
        new V1().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(AbstractBase::sum);
        return future.get();
    }
}
```
#### FutureTask
FutureTask 实现方式

```java
/**
 * @author ck
 * FutureTask 实现
 */
public class V2 extends AbstractBase{

    public static void main(String[] args) {
        new V2().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        FutureTask<Integer> task = new FutureTask<>(AbstractBase::sum);
        new Thread(task).start();
        return task.get();
    }
}
```

#### CountDownLatch
CountDownLatch 实现
```java
/**
 * @author ck
 * CountDownLatch 实现
 */
public class V3 extends AbstractBase{

    public static void main(String[] args) {
        new V3().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        CountDownLatch latch = new CountDownLatch(1);
        AtomicInteger result = new AtomicInteger();
        new Thread(() -> {
            try {
                result.set(sum());
            }finally {
                latch.countDown();
            }
        }).start();
        latch.await();
        return result.get();
    }
}
```

#### CyclicBarrier
CyclicBarrier 实现，和 CountDownLatch 很相似的一个方法，CountDownLatch 是采用减数的方式，它采用的是家数的方式。

```java
/**
 * @author ck
 * CyclicBarrier 实现
 */
public class V4 extends AbstractBase {

    public static void main(String[] args) {
        new V4().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        AtomicInteger result = new AtomicInteger();
        CyclicBarrier barrier = new CyclicBarrier(2);
        new Thread(() -> {
            try {
                result.set(sum());
                barrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }).start();
        barrier.await();
        return result.get();
    }
}
```

#### Semaphore
Semaphore 实现

```java
/**
 * @author ck
 * Semaphore 实现
 */
public class V5 extends AbstractBase {

    public static void main(String[] args) {
        new V5().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        Semaphore s = new Semaphore(0);
        AtomicInteger result = new AtomicInteger();
        new Thread( () -> {
            result.set(sum());
            s.release();
        } ).start();
        try {
            s.acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
        return result.get();

    }
}
```

#### wait()
wait() 实现

```java
/**
 * @author ck
 * wait & notify
 */
public class V6 extends AbstractBase {

    public static void main(String[] args) {
        new V6().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        Object o = new Object();
        AtomicInteger result = new AtomicInteger();
        new Thread(() -> {
            synchronized (o) {
                result.set(sum());
                o.notify();
            }
        }).start();
        synchronized (o) {
            o.wait();
        }
        return result.get();
    }
}
```

#### Future
Future 实现

```java
/**
 * @author ck
 * Future 实现
 */
public class V7 extends AbstractBase {

    public static void main(String[] args) {
        new V7().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        ThreadPoolExecutor pool = getPool(1, 1);
        Future<Integer> result = pool.submit(AbstractBase::sum);
        return result.get();
    }
}
```

#### join()
join() 实现

```java
/**
 * @author ck
 * join 实现
 */
public class V8 extends AbstractBase {

    public static void main(String[] args) {
        new V8().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        AtomicInteger result = new AtomicInteger();
        Thread thread = new Thread(() -> result.set(sum()));
        thread.start();
        thread.join();
        return result.get();
    }
}
```

#### LockSupport
LockSupport 实现
```java
/**
 * @author ck
 * LockSupport 实现
 */
public class V9 extends AbstractBase {

    public static void main(String[] args) {
        new V9().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        AtomicInteger result = new AtomicInteger();
        Thread main = Thread.currentThread();
        new Thread(() -> {
            try {
                result.set(sum());
            }finally {
                LockSupport.unpark(main);
            }
        }).start();
        LockSupport.park();
        return result.get();
    }
}
```

#### BlockingQueue 
BlockingQueue 阻塞队列

```java
/**
 * @author ck
 * BlockingQueue 实现
 */
public class V10 extends AbstractBase{

    public static void main(String[] args) {
        new V10().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(1);
        new Thread(() -> {
            try {
                queue.put(sum());
            } catch (InterruptedException e) {
                e.printStackTrace();
                Thread.currentThread().interrupt();
            }
        }).start();
        return queue.take();
    }
}
```

#### Lock&Condition
Lock & Condition 实现
```java
/**
 * @author ck
 * Lock & Condition 实现
 */
public class V11 extends AbstractBase {

    public static void main(String[] args) {
        new V11().template();
    }

    @Override
    public int asyncInvoke() throws Exception {
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        AtomicInteger result = new AtomicInteger();
        new Thread(() -> {
           try {
               lock.lock();
               result.set(sum());
               condition.signal();
           }finally {
               lock.unlock();
           }
        }).start();
        try {
            lock.lock();
            condition.await();
        }finally {
            lock.unlock();
        }
        return result.get();
    }
}
```

以上就是多线程下各个线程通讯的方式中的几种。

---

<center>月是家乡圆</center>

