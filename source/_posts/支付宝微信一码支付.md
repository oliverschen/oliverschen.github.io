---
title: 支付宝微信一码支付
date: 2019-12-01 09:26:20
tags: Pay
category: Pay
comments: true
---

![Photo by kejsirajbek on wallhaven.cc](/alipay-wechatpay-qr.png)

前几天有个需求要将支付宝和微信扫码集中在同一个二维码上面。当时已经上线了微信各种渠道支付（Native，公众号，H5）,支付宝上线了 Native，H5 支付，于是开始了一码多付的开发。在开发过程中也碰到了一些问题，好在快速解决了问题。
<!--more-->


##### 问题

1. 微信
从微信官方文档了解到扫码支付需要使用公众号支付方式拉起支付进行支付，这个过程需要进行用户认证等操作，从开发的角度来讲比较麻烦，而且多了认证操作，虽然可以使用静默授权（微信提供的一种用户无感知的授权方式）但是在加载过程中需要耗费更多的时间，用户体验降低。
2. 支付宝
支付宝支付在官方了解到使用当面付功能可以完成扫码支付，前端 jssdk 也具备拉起的方式。但是在开发过程中发现公司账号没有开通此功能，申请需要 1-2 天时间，时间上来不及，于是和前端同学试了支付宝也采用 H5 支付的方式，结果完美解决。支付宝还是很方便的，在交互还是开发方面。
3. 对账
这里其实可以不用回调也可以的，因为没有业务逻辑需要在回调处理，但是因为公司也使用H5,Native 支付 方式，所以这里需要记录下，方便后期对账等操作。

##### 思路
前端页面使用 userAgent 判断是微信还是支付宝扫码进入的，如果是支付宝，跳转到支付宝 H5 支付的方式，后端返回 H5 支付返回的 Form 表单，前端直接拉起支付宝支付。如果是微信扫码进来，则跳转到微信支付静默授权链接，后端处理跳转到相应的 H5 支付页面进行处理。完成之后把前端判断是支付宝还是微信的页面生成二维码作为入口，就可以完美实现了。

##### alipay

1. 引入支付宝提供的 SDK

```xml
<!--支付宝sdk-->
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>4.7.1.ALL</version>
</dependency>
```

2. 配置文件
```properties
# 是否启用沙盒支付
alipay.sandbox=false
# 支付宝后台获取 appId
alipay.appId=your.app.id
# 私有 key
alipay.privateKey=your.private.key
# 公有 key
alipay.alipayPublicKey=your.public.key
# 回调
alipay.qr.notifyUrl=https://${your.domain}/alipay/notify
```

3. 配置
```java
@Data
@Component
public class AlipayProperties {

    /**
     * 是否沙箱环境
     */
    @Value("${alipay.sandbox}")
    private Boolean isTest;
    /**
     * 应用ID
     */
    @Value("${alipay.appId}")
    private String appId;
    /**
     * 应用私钥
     */
    @Value("${alipay.privateKey}")
    private String privateKey;
    /**
     * 支付宝公钥
     */
    @Value("${alipay.alipayPublicKey}")
    private String alipayPublicKey;

    /**
     * 支付异步回调地址
     */
    @Value("${alipay.notifUrl}")
    private String notifyUrl;

    /**
     * 获取当前配置环境网关
     */
    public String obtainUrl() {
        // 沙盒环境
        if (this.isTest) {
            return "https://openapi.alipaydev.com/gateway.do";
        } else {
            return "https://openapi.alipay.com/gateway.do";
        }
    }

}

```

4. 对接

**支付controller**
```java
/**
    * 支付宝扫码支付
    */
@RequestMapping("/alipay")
public ResponseMsg qrAlipay(HttpServletRequest request,
                            @RequestBody QrPayRequestParams qrPayRequestParams,
                            @RequestHeader(value = "activityId", required = false) String activityId) {
    // 参数校验省略
    qrPayRequestParams.setRemoteAddr(request.getRemoteAddr());
    // 活动标记
    qrPayRequestParams.setActivityId(activityId);
    log.info("支付宝扫码参数：{}", qrPayRequestParams.toString());
    AliResultParams params = qrPaymentService.qrAlipay(qrPayRequestParams);
    ResponseMsg<AliResultParams> msg = new ResponseMsg<>(Code.SUCCESSED, Constants.SUCCESS);
    msg.setData(params);
    return msg;
}
```
**支付service**
```java
//存在多个回调，这里指定到具体回调
@Value("${alipay.qr.notifyUrl}")
private String alipayQrNotifyUrl;
/**
    * 支付宝扫码支付
    * @param qrPayRequestParams params
    * @return form table
    */
@Override
public AliResultParams qrAlipay(QrPayRequestParams qrPayRequestParams) {
    // 创建订单-根据具体业务
    //QrRechargeOrder order = qrRechargeOrderService.createOrder(qrPayRequestParams, QrPayConstants.PAYWAY_ALIPAY);
    // 支付宝支付
    AlipayClient alipayClient = new DefaultAlipayClient(alipayProperties.obtainUrl(),
            alipayProperties.getAppId(), alipayProperties.getPrivateKey(),
            AlipayConstants.FORMAT_JSON, AlipayConstants.CHARSET_UTF8, alipayProperties.getAlipayPublicKey(),
            AlipayConstants.SIGN_TYPE_RSA2);
    AlipayTradeWapPayRequest request = new AlipayTradeWapPayRequest();
    AlipayTradeWapPayModel model = new AlipayTradeWapPayModel();
    //该笔订单允许的最晚付款时间，逾期将关闭交易。
    model.setTimeoutExpress("30m");
    model.setTotalAmount(qrPayRequestParams.getMoney());
    model.setSubject("XXXX");
    // 更具具体业务生成的订单号
    //model.setOutTradeNo(order.getRechargeOrderId());
    model.setOutTradeNo("201912011111111111");
    model.setProductCode("XXXX");
    request.setBizModel(model);
    request.setNotifyUrl(alipayQrNotifyUrl);
    request.setReturnUrl(qrPayRequestParams.getReturnUrl());
    try {
        log.info("支付宝扫码请求参数：{}",request.getTextParams());
        AlipayTradeWapPayResponse response = alipayClient.pageExecute(request);
        log.info("请求信息：{}",response.getBody());
        AliResultParams params = AliResultParams.builder().alipayParams(response.getBody()).build();
        if (response.getBody().contains(model.getOutTradeNo())) {
            params.setAlipayTradeNo(model.getOutTradeNo());
        }
        return params;
    } catch (AlipayApiException e) {
        e.printStackTrace();
        return AliResultParams.builder().build();
    }
}
```
###### 回调
**回调controller**
```java
/**
 * 支付宝扫码回调
 */
@RequestMapping("/alipay/notify")
public String alipayNotify(HttpServletRequest request) {
    log.info("进入支付宝扫码支付回调");
    try {
        return qrPaymentService.alipayNotify(request);
    } catch (AlipayApiException e) {
        e.printStackTrace();
        log.info("支付宝扫码支付回调失败");
        return "fail";
    }
}
```
**回调service**
```java
/**
 * 支付宝扫码支付回调
 */
@Override
public String alipayNotify(HttpServletRequest request) throws AlipayApiException {
    Map<String, String> map;
    Map<String, String[]> requestParams = request.getParameterMap();
    map = this.paramsString(requestParams);
    String outTradeNo = map.get("out_trade_no");
    String tradeStatus = map.get("trade_status");
    String tradeNo = map.get("trade_no");
    boolean signVerified = AlipaySignature.rsaCheckV1(map, alipayProperties.getAlipayPublicKey(),
            AlipayConstants.CHARSET_UTF8, AlipayConstants.SIGN_TYPE_RSA2);
    log.info("支付宝扫码参数：out_trade_no：{}，trade_status，{}，trade_no，{}，校验结果：{}",
            outTradeNo, tradeStatus, tradeNo,signVerified);
    // 校验订单-省略
    
    // 验签通过，验证金额通过
    return "success";
    // 检验失败
    return "fail";
}

/**
 * 拼接参数
 */
private Map<String, String> paramsString(Map<String, String[]> requestParams) {
    Map<String, String> map = new HashMap<>();
    for (String name : requestParams.keySet()) {
        String[] values = requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";
            System.out.println(valueStr);
        }
        map.put(name, valueStr);
    }
    log.info("支付宝扫码支付参数：{}",map);
    return map;
}
```
**entity**
```java
// 封装微信和支付宝请求实体
@Data
@ToString
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class QrPayRequestParams {

    private String openId;

    /**
     * 金额 - 元
     */
    private Double money;

    private String remoteAddr;
    private String activityId;
    private String returnUrl;
}

// 封装支付宝返回参数信息
@Data
@ToString
@Builder
public class AliResultParams {
    private String alipayParams;
    private String alipayTradeNo;
}
```
以上就完成了支付宝扫码支付的整个流程，手机网站支付的[官方文档](https://docs.open.alipay.com/203)。

##### weChat pay

这里使用了微信公众号支付，需要进行授权处理。个人感觉步骤比较繁琐。

###### 授权

微信[网页授权](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)官方说明，扫码支付时采用静默授权，用户无感知状态下完成支付动作。主要有以下几步（官网）：
1. 引导用户进入授权页面同意授权，获取code

以下链接可以直接复制到微信客户端打开
> https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&response_type=code&scope=snsapi_base&state=123#wechat_redirect


2. 通过code换取网页授权access_token（与基础支持中的access_token不同）

3. 如果需要，开发者可以刷新网页授权access_token，避免过期

4. 通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）

```java
/**
 * 静默授权页面跳转，这里 `/wx/gzh/pay/menu` 就是上面链接中的 redirect_uri 的内容，获取到openId之后重定向到具体的业务页面
 *
 * @param request 请求实体
 * @return 页面
*/
@RequestMapping("/wx/gzh/pay/menu")
public ModelAndView payGuguDou(HttpServletRequest request) {
    String code = request.getParameter("code");
    if (StringUtils.isBlank(code)) {
        throw new ParamDefectException(Code.WARN, "没有获取到用户微信code");
    }
    try {
        String openId = mpService.authorization(code);
        if (StringUtils.isBlank(openId)) {
            return null;
        }
        ModelAndView mv = new ModelAndView("redirect:" + htmlUrl + "/pay.html");
        mv.addObject("openId", openId);
        return mv;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}


/**
 * 获取 openId
 *
 * @param code code
 * @return result
*/
@Override
public String authorization(String code) {
    log.info("voi获取的code ： {}，开始调用网页授权", code);
    String wxUrl = "https://api.weixin.qq.com/sns/oauth2/access_token?appid=" + properties.getAppId()
            + "&secret=" + properties.getAppSecret() + "&code=" + code + "&grant_type=authorization_code";
    String weiUserJson = OkHttpUtil.getSent(wxUrl, null, null);
    JSONObject jsonObject = JSONObject.parseObject(weiUserJson);
    String openid = jsonObject.getString("openid");
    log.info(" voi结束调用网页授权，网页授权获取到的openid：{}", openid);
    return openid;
}

/**
 * 获取accessToken
 *
 * @param url 拉起支付的页面路径
 * @return info
*/
@Override
public ResponseMsg signature(String url) {
    this.getAccessToken();
    String noncestr = RandomUtils.getRandomStr();
    String timestamp = System.currentTimeMillis() + "";
    timestamp = timestamp.substring(0, timestamp.length() - 3);

    String string1 = "jsapi_ticket=" + jsToken + "&noncestr=" + noncestr +
            "&timestamp=" + timestamp + "&url=" + url;
    //加密
    String signature = SHAUtil.SHA1(string1);
    // 返回参数
    Map<String, String> o = new HashMap<>(8);
    o.put("jsapiticket", jsToken);
    o.put("noncestr", noncestr);
    o.put("timestamp", timestamp);
    o.put("url", url);
    o.put("signature", signature);
    o.put("appid", properties.getAppId());
    ResponseMsg<Map> msg = new ResponseMsg<>(Code.SUCCESSED, Constants.SUCCESS);
    msg.setData(o);
    return msg;
}

/**
 * 获取 ticket
*/
private void getAccessToken() {
    String accessTokenUrl = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=" +
            properties.getAppId() + "&secret=" + properties.getAppSecret();

    String sent = OkHttpUtil.getSent(accessTokenUrl, null, null);
    JSONObject accessJsonObject = JSONObject.parseObject(sent);
    String accessToken = accessJsonObject.getString("access_token");
    String jsTokenUrl = "https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=" + accessToken + "&type=jsapi";
    String jsTokenResult = OkHttpUtil.getSent(jsTokenUrl, null, null);
    JSONObject jsTokenJsonObject = JSONObject.parseObject(jsTokenResult);
    if (jsTokenJsonObject != null) {
        int errcode = jsTokenJsonObject.getInteger("errcode");
        if (errcode == 0) {
            jsToken = jsTokenJsonObject.getString("ticket");
        }
    }
}
```
完成以上动作，就完成了对用户的静默授权，**在这次扫码支付中，用户微信扫码进入到入口页面，通过 userAgent 判断时微信扫码进入后，直接跳转到下面授权链接（具体的参数需要自己的），然后开始输入金额进行支付** 
> https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&response_type=code&scope=snsapi_base&state=123#wechat_redirect


###### 拉起支付

**引入SDK**
我这里引入了第三方开源包，[官方地址](https://github.com/Pay-Group/best-pay-sdk)
```xml
<dependency>
    <groupId>cn.springboot</groupId>
    <artifactId>best-pay-sdk</artifactId>
    <version>1.2.0</version>
</dependency>
```

**配置文件**
```properties
# mp weChat pay
gzh.wx.appId=wx123456789
gzh.wx.appSecret=afjidshu434234hwier3432
gzh.wx.mchId=123456789
gzh.wx.apiKey=Ydfsdfkf565sdf45d4
qr.wx.notifyUrl=https://${your.domain}/wx/notify
```

**配置**
```java
@Data
@Component
@ConfigurationProperties
public class WxMpPayProperties {
    @Value("${gzh.wx.appSecret}")
    private String appSecret;
    /**
     * 设置微信公众号或者小程序等的appid
     */
    @Value("${gzh.wx.appId}")
    private String appId;

    /**
     * 微信支付商户号
     */
    @Value("${gzh.wx.mchId}")
    private String mchId;

    /**
     * 微信支付商户密钥
     */
    @Value("${gzh.wx.apiKey}")
    private String mchKey;

}
```


**支付Controller**
```java

/**
 * 微信扫码支付
 */
@RequestMapping("/wechat")
public ResponseMsg qrWechat(HttpServletRequest request,
                            @RequestBody QrPayRequestParams qrPayRequestParams,
                            @RequestHeader(value = "activityId",required = false) String activityId) {
    // 安全校验（参数合法性等）-省略

    qrPayRequestParams.setRemoteAddr(request.getRemoteAddr());
    // 活动ID
    qrPayRequestParams.setActivityId(activityId);
    log.info("微信扫码参数：{}", qrPayRequestParams.toString());
    try {
        WxPayMpOrderResult result = qrPaymentService.qrWechat(qrPayRequestParams);
        ResponseMsg<WxPayMpOrderResult> msg = new ResponseMsg<>(Code.SUCCESSED, Constants.SUCCESS);
        msg.setData(result);
        return msg;
    } catch (Exception e) {
        e.printStackTrace();
        return new ResponseMsg(Code.FAILED, "服务异常");
    }
}
```

**支付Service**
```java
//存在多个回调，这里指定到具体回调
@Value("${qr.wx.notifyUrl}")
private String wxQrNotifyUrl;
/**
* 微信二维码支付
*
* @param qrPayRequestParams params
* @return 支付参数
*/
@Override
public WxPayMpOrderResult qrWechat(QrPayRequestParams qrPayRequestParams) {

    // 创建订单-根据业务生成订单
    //QrRechargeOrder order = qrRechargeOrderService.createOrder(qrPayRequestParams,QrPayConstants.PAYWAY_WECHAT);
    //log.info("扫码支付创建订单：{}", order.toString());

    // 微信公众号支付参数
    PayRequest orderRequest = new PayRequest();
    orderRequest.setOpenid(qrPayRequestParams.getOpenId());
    //orderRequest.setOrderAmount(order.getPayMoney());
    orderRequest.setOrderAmount(1000);
    orderRequest.setOrderId(order.getRechargeOrderId());
    orderRequest.setSpbillCreateIp(qrPayRequestParams.getRemoteAddr());
    orderRequest.setOrderName("XXXX");
    orderRequest.setPayTypeEnum(BestPayTypeEnum.WXPAY_H5);
    //统一下单
    wxPayH5Config.setNotifyUrl(wxQrNotifyUrl);
    bestPayService.setWxPayH5Config(wxPayH5Config);
    PayResponse payResponse = bestPayService.pay(orderRequest);

    // 加签返回结果
    WxPayMpOrderResult payResult = WxPayMpOrderResult.builder()
            .appId(payResponse.getAppId())
            .timeStamp(String.valueOf(System.currentTimeMillis() / 1000))
            .nonceStr(payResponse.getNonceStr())
            .packageValue(payResponse.getPackAge())
            .signType("MD5")
            .build();
    payResult.setPaySign(SignUtils.createSign(payResult, null, this.wxPayH5Config.getMchKey(), new String[]{}));
    return payResult;
}
```

###### 回调
**回调Controller**
```java
/**
 * 微信支付回调
 */
@RequestMapping("/wx/notify")
public String wxNotify(@RequestBody String xmlData) {
    log.info("***********微信扫码回调参数：{}**************", xmlData);
    try {
        return qrPaymentService.wxNotify(xmlData);
    } catch (Exception e) {
        e.printStackTrace();
        log.error("微信扫码回调处理异常");
        return QrPayConstants.WX_NOTIFY_ERROR;
    }
}
```

**回调Service**
```java
 /**
    * 微信扫码支付回调
    *
    * @param xmlData 回调信息
    * @return 返回给微信服务器处理结果
    */
@Override
public String wxNotify(String xmlData) throws WxPayException {
    log.info("微信扫码回调开始解析");
    final WxPayOrderNotifyResult notifyResult = this.wxPayService.parseOrderNotifyResult(xmlData);
    log.info("解析结果{}", notifyResult.getOutTradeNo());
    if (!"SUCCESS".equals(notifyResult.getReturnCode()) || !"SUCCESS".equals(notifyResult.getResultCode())) {
        log.info("订单校验出错");
        return QrPayConstants.WX_NOTIFY_ERROR;
    }
    String rechargeOrderId = notifyResult.getOutTradeNo();
    // 具体的参数校验-省略
    
    // 校验成功
    return QrPayConstants.WX_NOTIFY_SUCCESS;
    // 校验失败
    return QrPayConstants.WX_NOTIFY_ERROR;
}
```
微信回调会走多次，在订单成功的情况下需要设置状态等确保成功业务只执行一次，避免多次调用后数据错乱等情况发生。



##### 总结
1. 需要前后端配置完成，前期需要沟通确认使用哪种方式处理。（开发过程中因为对接方式的原因，延误了一些时间）
2. 微信和支付宝的文档比较多，需要仔细阅读。

> 今天中午出门逛了一大圈，有空还是多出去走走，毕竟小命要紧，保持身体健康是最重要的。

***

<center>2019-12-01 12月的第一天，我和小扣去了盒马，我觉得我更爱她了</center>













