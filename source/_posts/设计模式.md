---
title: 设计模式
date: 2021-03-27 23:28:55
tags: 设计模式
category: 设计模式
comments: true
---

![Photo by sisko1701 on wallhaven.cc](/template.png)

设计模式是前人们总结出来一类问题的最优解，曾经看过一篇文章这样说的「假如你从来没有看过设计模式，但是当你真的写了很多代码之后，发现优化和抽象之后还是会对应到相应的设计模式上面去」既然已经总结出了好的方法，那我们也应该好好吸收理解，加以利用。能在真是的项目中投入使用，降低开发难度和成本。当然设计模式用在合适的业务中使用才能发挥它的价值，不要为了设计模式而使用设计模式。在真实场景中有时候会得不偿失。

<!--more-->

## 模板方法

### 概念

字面意思来理解就是说把完成一项事情所要做的过程抽象成一个模板。

#### 例子

比如我们去游乐场可以大致分为以下几个步骤：

![流程](/flow.jpeg)

上面几个流程其实前 3 个和最后一个大家做的事情是一样的，抽象成代码就是`窗口买票方法`，`检票入场方法`，`出口回家方法`。但是`玩`这里是不同的，因为每个人进来之后有的人喜欢刺激去玩过山车🎢，有的比较怂「我？」就去玩儿童项目。哈哈，总之 玩这个方法对于每个人来说都是变动的，所以把它抽象出来，交给子类，也就是每个人去实现自己的玩方法，其他方法放在父类中，统一处理，这就是模板方法，简单而实用。

### 实现

接着上面游乐场的例子，用代码实现的话是下面这样的。

#### 游乐场

```java
/**
 * @author ck
 */
public abstract class Playground {

    /**
     * 游玩所有流程
     */
    public void playTemplate() {
        buyTicket();
        checkTicket();
        play();
        goHome();
    }

    /**
     * 窗口统一买票
     */
    public void buyTicket() {
        System.out.println("我买到双人票了！");
    }

    /**
     * 统一排队检票
     */
    public void checkTicket() {
        System.out.println("检票入场了");
    }

    /**
     * 统一出口离开
     */
    public void goHome() {
        System.out.println("我们从出口回家了");
    }

    /**
     * 玩：每个人玩法都不一样
     */
    public abstract void play();
}
```

#### 游客

李明

```java
public class Liming extends Playground{
    @Override
    public void play() {
        System.out.println("我先玩了过山车🎢，然后又玩了跳楼机。。。。哈哈哈");
    }
}
```

张三

```java
public class Zhangsan extends Playground{

    @Override
    public void play() {
        System.out.println("儿童项目真好玩😄");
    }
}
```

#### 测试

让两个游客都执行相同的方法，但是看到的模板中执行的结果是不一样的。

```java
public class Main {

    public static void main(String[] args) {
        Liming liming = new Liming();
        liming.playTemplate();
        System.out.println("=================");
        Zhangsan zhangsan = new Zhangsan();
        zhangsan.playTemplate();
    }
}
```

#### 结果

```bash
我买到双人票了！
检票入场了
我先玩了过山车🎢，然后又玩了跳楼机。。。。哈哈哈
我们从出口回家了
=================
我买到双人票了！
检票入场了
儿童项目真好玩😄
我们从出口回家了

Process finished with exit code 0
```

### 总结
可以看得出来，模板的好处就是将不变的抽离出来，放在一个父类中，将变化的留出入口，让不同的子类是实现自己对应的方法。简单且实用，我之前在工作中有对接第三方提现业务，但是因为财务和运营各方原因「对内这样说的」接了4家左右的第三方公司，而且说后续还可能陆续会有。在这个需求中我发现很多方法，比如创建提现订单，创建提现记录，提现信息校验等一些基础方法是不变的，而请求第三发发起提现，实名认证，查询在第三方账户余额是不一样的。所以采用了模板的方式来实现这个需求，让代码的冗余度减少很多，完美的解决了问题。而对于以后再接入新的服务商，我也是需要实现抽象类，然后在抽象方法中实现与他的对接就行了，其他基本保持不变。

## 策略模式

### 概念

简答理解就是完成一件事情有很多种 `策略/方式` ，在不同条件下使用的 `策略/方式` 不同。策略模式就是根据实际情况来选择不同的 `策略/方式` 来完成工作。

### 例子

比如有款氪金游戏，给用户提供了各种五花八门的充值渠道  `iOS` ， `支付宝` ， `支付宝H5` , `微信` ， `微信H5` 等。 用户完成一次充值大概分为以下步骤：

![策略模式流程](/strategy.jpeg)

支付这个场景我们基本每天都会碰到，这每种方式其实对应起来就是一种策略，在充值的时候告诉应用要通过哪种方式支付，在服务端会唤起相应的支付策略。一般策略模式配合模板方法能更好的实现业务功能。

### 实现

使用 Spring 容器能更好更快捷的实现策略模式，主要包含下面几个组件：

UnionPayFactory：工厂类，负责保存各种策略类

UnionPayStrategy: 支付业务策略类接口

各种实现：UnionPayFactory 的具体实现，完成各自的流程

#### UnionPayFactory

利用 Spring 的自动注入特性，将实现了 UnionPayFactory 接口的 Bean 全部缓存在工厂的并发容器中，以便后续调用时方便使用。

```java
/**
 * 统一支付工厂
 * 2020-06-30 11:45
 */
@Component
public class UnionPayFactory {

    final Map<String, UnionPayStrategy> MAP = Maps.newConcurrentMap();

    @Autowired
    public UnionPayFactory(List<UnionPayStrategy> list) {
        list.forEach(item -> {
            Component anno = item.getClass().getAnnotation(Component.class);
            MAP.put(anno.value(), item);
        });
    }

    /**
     * 获取对应策略
     *
     * @param name 策略实现类名称
     */
    public UnionPayStrategy getStrategy(String name) {
        UnionPayStrategy strategy = MAP.get(name);
        if (Objects.isNull(strategy)) {
            throw new ParamDefectException(Code.FAILED, ERROR_PARAMS);
        }
        return MAP.get(name);
    }


}
```

#### UnionPayStrategy

定义支付策略接口有哪些能力，待自己的实现类去实现。

```java
/**
 * 支付策略
 * 2020-06-30 11:45
 */
public interface UnionPayStrategy {

    /**
     * 充值
     * @param vo RechargeVO
     * @return RechargeOut
     */
    PayOut recharge(PayVO vo);
}
```

#### UnionPayServiceImpl

这些代码都是实际业务中的一些片段，有些涉及具体业务的代码我删除了...

```java
/**
 * 统一支付
 * 2020-06-30 11:11
 */
@Slf4j
@Service
public class UnionPayServiceImpl implements UnionPayService {

    @Autowired
    private UnionPayFactory factory;

    /**
     * 充值
     *
     * @param vo RechargeVO
     * @return RechargeOut
     */
    @Override
    public PayOut pay(PayVO vo) {
        // 1. 获取对应策略
        UnionPayStrategy strategy = factory.getStrategy(vo.getChannel().getComp());
        // 2. 调用对应的充值方法进行充值
        return strategy.recharge(vo);
    }
}
```

#### 支付宝

支付宝策略实现类中大致是这样的

```java
/**
 * 支付宝
 * 2020-06-30 11:52
 */
@Slf4j
@Component("ALIPAY")
public class AlipayStrategy implements UnionPayStrategy {

    // 基类，将创建订单等工作抽取到这里
    @Autowired
    private BaseUnionPay baseUnionPay;

    /**
     * 充值
     */
    @Override
    public PayOut recharge(PayVO vo) {
        ChaUser user = getAlipayUser(vo.getChannel(), vo.getMobile());
        Order order = baseUnionPay.createOrder(user, vo);
        try {
            AlipayResponse response = requestAlipay(order, vo);
            if (Objects.isNull(response)) {
                throw new ParamDefectException(Code.FAILED, "支付失败");
            }
            return new PayOut("", response.getBody(), "");
        } catch (AlipayApiException e) {
            log.error("支付宝充值异常", e);
            throw new ParamDefectException(Code.FAILED, "充值失败");
        }
    }
}
```

#### 测试

在调用接口是传入各个策略实现类的组件名称 `@Component("ALIPAY")` 的组件名称就是 `ALIPAY` 这个字符串，工厂通过这个字符串会获取到 `AlipayStrategy` 这个具体策略调用这个策略的充值接口完成对应的充值操作。

### 总结

策略模式是最常用的一个设计模式之一，它的好处是可以将业务从各种复杂多余的 `if else` 代码中抽离出来，形成相对独立又统一的实现。如果要增加新的策略或者减去已有策略时就非常方便，只要将其加入注解或者删掉就行，不会对原有业务产生任何影响。但是如果一个判断里面没有什么业务，只是些简单的判断，不建议使用策略模式去解决，反倒会增加维护成本，写一大堆没有用的类在里面，所以在使用时还需要和实际情况进行权衡。



***

慢慢更新，争取所有的模式都能用到我自己真是工作中，并带来正收益。

<center></center>